---
title: "SL-HW2"
output:
  html_document:
    highlight: kate
    toc: yes
---

```{r eval = FALSE}
renv::restore()

# or

renv::install(
  c(
    "data.table",
    "kernlab",
    "doFuture",
    "tidymodels",
    "readr",
    "RColorBrewer",
    "ggplot2",
    "plotly"
  )
)
```

```{r echo = FALSE}
library(data.table)

library(kernlab)
# library(dimRed)

library(parallel)
library(doFuture)

# library(caret)
library(tidymodels)
library(readr)

library(RColorBrewer)
library(ggplot2)
library(plotly)
```

Load csv file

```{r}
data <- data.table::fread("train4final_hw.csv")
```

Parallel

```{r eval = FALSE}
num_cores <- parallel::detectCores() - 1
registerDoFuture()
```

# EDA

## Which features are most (linearly) correlated to tempo
```{r}
cor(data[, -c("tempo", "id")], y = data$tempo) %>% 
    tibble("corr" = as.vector(.), "feat" = rownames(.)) %>%
    mutate("abs_corr" = abs(corr), feat) %>%
    arrange(desc(abs_corr)) %>%
    head(1000) %>%
    select(feat, abs_corr) %>%
    ggplot() +
      aes(x = abs_corr, y = reorder(feat, abs_corr)) +
      geom_col(position=position_dodge(), width = 0.8) +
      theme(axis.text=element_text(size=5))
```

## Which not MEL feature are most (linearly) correlated to tempo
```{r}
cor(data[, -c(1:6840)], y = data$tempo) %>%
    tibble("corr" = as.vector(.), "feat" = rownames(.)) %>%
    filter(feat != "tempo" & feat != "id") %>%
    mutate("abs_corr" = abs(corr), feat) %>%
    arrange(desc(abs_corr)) %>%
    select(feat, abs_corr) %>%
    head(50) %>%
    ggplot() +
      aes(x = abs_corr, y = reorder(feat, abs_corr)) +
      geom_col(position=position_dodge(), width = 0.8) +
      theme(axis.text=element_text(size=5))
```

## Which features are most (linearly) correlated to the frequency median
```{r}
cor(data[, -c(1:7011)], y = data$freq.M) %>%
    tibble("corr" = as.vector(.), "feat" = rownames(.)) %>%
    filter(feat != "freq.M" & feat != "id") %>%
    mutate("abs_corr" = abs(corr), feat) %>%
    arrange(desc(abs_corr)) %>%
    select(feat, abs_corr) %>%
    head(50) %>%
    ggplot() +
      aes(x = abs_corr, y = reorder(feat, abs_corr)) +
      geom_col(position=position_dodge(), width = 0.8) +
      theme(axis.text=element_text(size=5))
```

```{r}
data %>%
  as_tibble() %>%
  ggplot() +
    aes(x = tempo, y = genre) +
    geom_point() +
    scale_colour_gradientn(colours = RColorBrewer::brewer.pal(4, "RdYlBu"))
```

<!-- ```{r eval = FALSE} -->
<!-- audio_num <- 2 -->
<!-- audio <- matrix(X[audio_num,1:6840], nrow = 171, ncol = 40) %>% scale() -->

<!-- col_palette <- c("#FCFFA4FF",  -->
<!--                  "#F5DB4BFF",  -->
<!--                  "#FCAD12FF",  -->
<!--                  "#F78311FF",  -->
<!--                  "#E65D2FFF",  -->
<!--                  "#CB4149FF", -->
<!--                  "#A92E5EFF",  -->
<!--                  "#85216BFF",  -->
<!--                  "#60136EFF",  -->
<!--                  "#3A0963FF",  -->
<!--                  "#140B35FF",  -->
<!--                  "#000004FF") -->

<!-- audio_smooth <- oce::matrixSmooth(audio, passes = 2) -->

<!-- image(x = 1:171, y = 1:40, z = audio_smooth,  -->
<!--       xlab = "Time instants", ylab = "Mel-Frequencies", -->
<!--       col = col_palette) -->
<!-- ``` -->


# Dimensionality reduction

Exclude `id`, `genre`, `tempo` columns from the dataset, and put aside the`tempo`

```{r eval = FALSE}
X  <- data[,-c("id", "tempo", "genre")]
tempo <- data$tempo
```


<!-- ## Pre-PCA -->

<!-- ### ALT1 - Only keep columns related to the MEL coeffs, time statistics and signal statistics -->
<!-- ```{r eval = FALSE} -->
<!-- mel_columns <- 1:6840 -->
<!-- time_columns <- 7012:7015 -->
<!-- signal_columns <- 7034:7039 -->

<!-- X_red <- X[, c(mel_columns, time_columns, signal_columns)] -->
<!-- ``` -->

<!-- ### ALT2 - Smooth the MEL coeffs -->
<!-- ```{r eval = FALSE} -->
<!-- smoothRow <- function(row, nrow, ncol, passes){ -->
<!--   matrix(row, nrow = nrow, ncol = ncol) %>% -->
<!--     scale() %>% -->
<!--     t() %>% -->
<!--     oce::matrixSmooth(., passes = passes) %>% -->
<!--     ramify::flatten(., across = "rows") %>% -->
<!--     return() -->
<!-- } -->

<!-- mel_columns <- 1:6840 -->
<!-- time_columns <- 7012:7015 -->
<!-- signal_columns <- 7034:7039 -->

<!-- X_red <- X[, c(mel_columns, time_columns, signal_columns)] -->
<!-- X_red[, mel_columns] <- X_red[, mel_columns] %>%  -->
<!--   apply(MARGIN = 1, FUN = function(row) smoothRow(row, nrow = 171, ncol = 40, passes = 2)) %>%  -->
<!--   t() -->

<!-- # image(x = 1:171, y = 1:40, z = matrix(X_red[2, mel_columns], nrow = 171, ncol = 40),  -->
<!-- #       xlab = "Time instants", ylab = "Mel-Frequencies", -->
<!-- #       col = col_palette) -->
<!-- ``` -->

## Linear PCA of all MEL coefficients

```{r eval = FALSE}
# X_kpca_mel <- X[, 1:6840] %>%
#   scale() %>%
#   kpca(x = .,
#        kernel = "laplacedot",
#        kpar = list(sigma = 0.00001),
#        features = 100) %>%
#   pcv() %>%
#   as.data.frame()

pc <- X[, 1:6840] %>%
  prcomp(center = TRUE, scale = TRUE)

X_pca_mel <- pc$x[, 1:50] %>% as.data.frame()
  
colnames(X_pca_mel) <- paste("pc_mel", 1:ncol(X_pca_mel), sep = "")
```

Check separation of the components

```{r eval = FALSE}
X_pca_mel %>% 
  ggplot(aes(pc_mel3, pc_mel5)) + 
  geom_point(aes(colour = tempo)) + 
  scale_colour_gradientn(colours = RColorBrewer::brewer.pal(4, "RdYlBu"))
```

## Kernel PCA of all dominant frequencies and frequency related statistics

```{r eval = FALSE}
X_kpca_freq <- X[, c(6841:7011, 7016:7032, 7034:7039)] %>%
  scale() %>%
  kpca(x = .,
       kernel = "rbfdot",
       kpar = list(sigma = 0.3),
       features = 10) %>%
  pcv() %>%
  as.data.frame()

colnames(X_kpca_freq) <- paste("pc_freq", 1:ncol(X_kpca_freq), sep = "")
```

Check separation of the components

```{r eval = FALSE}
X_kpca_freq %>%
  ggplot(aes(pc_freq1, pc_freq2)) +
  geom_point(aes(colour = tempo)) +
  scale_colour_gradientn(colours = RColorBrewer::brewer.pal(4, "RdYlBu"))
```

```{r eval = FALSE}
X_kpca_freq %>% plot_ly(
  x = ~ pc_freq1,
  y = ~ pc_freq2,
  z = ~ pc_freq3,
  type = "scatter3d",
  size = 1,
  mode = "markers",
  color = tempo,
  colors = "RdYlBu"
)
```

## Group everything in final dataset

We kept everything except for the `time` columns in the original dataset
```{r eval = FALSE}
X_red <- cbind(X_pca_mel, X_kpca_freq)
```

# Modelling 

```{r eval = FALSE}
data_to_model <- tibble(X_red)
data_to_model$tempo <- tempo
```

Steps

1.  Split data in 70% Training and 30% Testing with stratified sampling

2.  Pick model

3.  Grid search to find best parameters using k-Fold Cross Validation

4.  Fit with the best parameters and compute RMSE

Training/testing

```{r eval = FALSE}
set.seed(123)
tr_te_split <- data_to_model %>% initial_split(prop = 0.7, strata = tempo)

training <- training(tr_te_split)
testing <- testing(tr_te_split)
```

### SVM RBF

<https://www.tidymodels.org/start/tuning/>

```{r eval = FALSE}
# model
svm_rbf_spec <- svm_rbf(cost = tune(), rbf_sigma = tune()) %>%
  set_mode("regression") %>%
  set_engine("kernlab")

# fitting workflow
svm_rbf_wf <- workflow() %>%
  add_model(svm_rbf_spec) %>%
  add_formula(tempo ~ .)

# parallel computing
cl <- makeCluster(num_cores)
plan(cluster, workers = cl)

# construct a 5x5 grid of sensible values
# of cost and sigma to check
svm_rbf_grid <- grid_regular(cost(), rbf_sigma(), levels = 5)

# 5 folds for cross validation
folds <- vfold_cv(training, v = 5, strata = tempo)

# fit for each set of folds
# for all parameters in the grid
svm_rbf_res <- svm_rbf_wf %>%
  tune_grid(resamples = folds,
            grid = svm_rbf_grid)
```

Compare the parameters

```{r eval = FALSE}
svm_rbf_res %>%
  collect_metrics() %>%
  mutate(cost = factor(cost)) %>%
  ggplot(aes(rbf_sigma, mean, color = cost)) +
  geom_line(size = 1.5, alpha = 0.6) +
  geom_point(size = 2) +
  facet_wrap(~ .metric, scales = "free", nrow = 2) +
  scale_x_log10(labels = scales::label_number()) +
  scale_color_viridis_d(option = "plasma", begin = .9, end = 0)
```

Fit with the best parameters
<https://tune.tidymodels.org/reference/last_fit.html>

```{r eval = FALSE}
best_svm <- svm_rbf_res %>% select_best("rmse")

svm_rbf_wf_final <- svm_rbf_wf %>% finalize_workflow(best_svm)

svm_rbf_fit <- svm_rbf_wf_final %>% last_fit(tr_te_split) 
stopCluster(cl)
```

Final RMSE

```{r eval = FALSE}
svm_rbf_fit %>% 
  collect_metrics() %>% 
  filter(.metric == "rmse") %>%
  select(.estimate) %>%
  deframe %>%
  paste("RMSE =", .) %>%
  cat()
```

```{r eval = FALSE}
svm_rbf_fit$.predictions
```

Save model
<https://community.rstudio.com/t/saving-a-model-fit-with-tidymodels/114839>

```{r eval = FALSE}
svm_rbf_fit %>% 
  extract_workflow() %>% 
  readr::write_rds("svm_rbf.rds")
```

### Random Forest

```{r eval = FALSE}
# model
rf_spec <- rand_forest(mtry = tune(), trees = tune()) %>%
  set_mode("regression") %>%
  set_engine("ranger")

# fitting workflow
rf_wf <- workflow() %>%
  add_model(rf_spec) %>%
  add_formula(tempo ~ .)

# parallel computing
cl <- makeCluster(num_cores)
plan(cluster, workers = cl)

num_features <- data_to_model[[1]] %>% ncol()

# construct a grid of values
# of mtry and trees to check
rf_grid <- expand.grid(
          mtry =  floor(num_features * c(0.1, 0.2, 0.5, 0.99)), 
          trees = c(200, 500, 1000, 2000)
        )

# 10 folds for cross validation
folds <- vfold_cv(training, v = 10, strata = tempo)

# fit for each set of folds
# for all parameters in the grid
rf_res <- rf_wf %>%
  tune_grid(resamples = folds,
            grid = rf_grid)
```

Compare the parameters

```{r eval = FALSE}
rf_res %>%
  collect_metrics() %>%
  mutate(mtry = factor(mtry)) %>%
  ggplot(aes(trees, mean, color = mtree)) +
  geom_line(size = 1.5, alpha = 0.6) +
  geom_point(size = 2) +
  facet_wrap(~ .metric, scales = "free", nrow = 2) +
  scale_x_log10(labels = scales::label_number()) +
  scale_color_viridis_d(option = "plasma", begin = .9, end = 0)
```

Fit with the best parameters
<https://tune.tidymodels.org/reference/last_fit.html>

```{r eval = FALSE}
best_rf <- rf_res %>% select_best("rmse")

rf_wf_final <- rf_wf %>% finalize_workflow(best_rf)

rf_fit <- rf_wf_final %>% last_fit(tr_te_split) 
stopCluster(cl)
```

Final RMSE

```{r eval = FALSE}
rf_fit %>% 
  collect_metrics() %>% 
  filter(.metric == "rmse") %>%
  select(.estimate) %>%
  deframe %>%
  paste("RMSE =", .) %>%
  cat()
```
