---
title: "SL-HW2"
output:
  html_document:
    highlight: kate
    toc: yes
---

```{r Install libraries, eval = FALSE}
renv::restore()

# or

renv::install(
  c(
    "data.table",
    "kernlab",
    "doFuture",
    "tidymodels",
    "readr",
    "RColorBrewer",
    "ggplot2",
    "plotly"
  )
)
```

```{r Load libraries}
suppressMessages(require(data.table, quietly = T))

suppressMessages(require(kernlab, quietly = T))

suppressMessages(require(parallel, quietly = T))
suppressMessages(require(doFuture, quietly = T))

suppressMessages(require(tidymodels, quietly = T))
suppressMessages(require(readr, quietly = T))

suppressMessages(require(RColorBrewer, quietly = T))
suppressMessages(require(ggplot2, quietly = T))
suppressMessages(require(plotly, quietly = T))
```

Load csv file

```{r Load csv}
data <- data.table::fread("train4final_hw.csv")
```

Parallel

```{r Parallel initialization, eval = FALSE}
num_cores <- parallel::detectCores() - 1
registerDoFuture()
```

# EDA

## Which features are most (linearly) correlated to tempo
```{r Correlation to tempo, warnings = F}
cor(data[, -c("tempo", "id")], y = data$tempo) %>% 
    tibble("corr" = as.vector(.), "feat" = rownames(.)) %>%
    mutate("abs_corr" = abs(corr), feat) %>%
    arrange(desc(abs_corr)) %>%
    head(1000) %>%
    select(feat, abs_corr) %>%
    ggplot() +
      aes(x = abs_corr, y = reorder(feat, abs_corr)) +
      geom_col(position=position_dodge(), width = 0.8) +
      theme(axis.text=element_text(size=5))
```

## Which not MEL feature are most (linearly) correlated to tempo
```{r Correlation of MEL to tempo, warnings = F}
cor(data[, -c(1:6840)], y = data$tempo) %>%
    tibble("corr" = as.vector(.), "feat" = rownames(.)) %>%
    filter(feat != "tempo" & feat != "id") %>%
    mutate("abs_corr" = abs(corr), feat) %>%
    arrange(desc(abs_corr)) %>%
    select(feat, abs_corr) %>%
    head(50) %>%
    ggplot() +
      aes(x = abs_corr, y = reorder(feat, abs_corr)) +
      geom_col(position=position_dodge(), width = 0.8) +
      theme(axis.text=element_text(size=5))
```

## Which features are most (linearly) correlated to the frequency median
```{r Correlation to frequency median, warnings = F}
cor(data[, -c(1:7011)], y = data$freq.M) %>%
    tibble("corr" = as.vector(.), "feat" = rownames(.)) %>%
    filter(feat != "freq.M" & feat != "id") %>%
    mutate("abs_corr" = abs(corr), feat) %>%
    arrange(desc(abs_corr)) %>%
    select(feat, abs_corr) %>%
    head(50) %>%
    ggplot() +
      aes(x = abs_corr, y = reorder(feat, abs_corr)) +
      geom_col(position=position_dodge(), width = 0.8) +
      theme(axis.text=element_text(size=5))
```

```{r Tempo vs genre}
data %>%
  as_tibble() %>%
  ggplot() +
    aes(x = genre, y = tempo) +
    geom_point() +
    scale_colour_gradientn(colours = RColorBrewer::brewer.pal(4, "RdYlBu"))
```

<!-- ```{r eval = FALSE} -->
<!-- audio_num <- 2 -->
<!-- audio <- matrix(X[audio_num,1:6840], nrow = 171, ncol = 40) %>% scale() -->

<!-- col_palette <- c("#FCFFA4FF",  -->
<!--                  "#F5DB4BFF",  -->
<!--                  "#FCAD12FF",  -->
<!--                  "#F78311FF",  -->
<!--                  "#E65D2FFF",  -->
<!--                  "#CB4149FF", -->
<!--                  "#A92E5EFF",  -->
<!--                  "#85216BFF",  -->
<!--                  "#60136EFF",  -->
<!--                  "#3A0963FF",  -->
<!--                  "#140B35FF",  -->
<!--                  "#000004FF") -->

<!-- audio_smooth <- oce::matrixSmooth(audio, passes = 2) -->

<!-- image(x = 1:171, y = 1:40, z = audio_smooth,  -->
<!--       xlab = "Time instants", ylab = "Mel-Frequencies", -->
<!--       col = col_palette) -->
<!-- ``` -->


# Dimensionality reduction

Exclude `id` and `tempo` columns from the dataset, and put aside the`tempo`

```{r Starting data matrix, eval = FALSE}
# X  <- data[,-c("id", "tempo", "genre")]
X  <- data[,-c("id", "tempo")]
tempo <- data$tempo
```


<!-- ## Pre-PCA -->

<!-- ### ALT1 - Only keep columns related to the MEL coeffs, time statistics and signal statistics -->
<!-- ```{r eval = FALSE} -->
<!-- mel_columns <- 1:6840 -->
<!-- time_columns <- 7012:7015 -->
<!-- signal_columns <- 7034:7039 -->

<!-- X_red <- X[, c(mel_columns, time_columns, signal_columns)] -->
<!-- ``` -->

<!-- ### ALT2 - Smooth the MEL coeffs -->
<!-- ```{r eval = FALSE} -->
<!-- smoothRow <- function(row, nrow, ncol, passes){ -->
<!--   matrix(row, nrow = nrow, ncol = ncol) %>% -->
<!--     scale() %>% -->
<!--     t() %>% -->
<!--     oce::matrixSmooth(., passes = passes) %>% -->
<!--     ramify::flatten(., across = "rows") %>% -->
<!--     return() -->
<!-- } -->

<!-- mel_columns <- 1:6840 -->
<!-- time_columns <- 7012:7015 -->
<!-- signal_columns <- 7034:7039 -->

<!-- X_red <- X[, c(mel_columns, time_columns, signal_columns)] -->
<!-- X_red[, mel_columns] <- X_red[, mel_columns] %>%  -->
<!--   apply(MARGIN = 1, FUN = function(row) smoothRow(row, nrow = 171, ncol = 40, passes = 2)) %>%  -->
<!--   t() -->

<!-- # image(x = 1:171, y = 1:40, z = matrix(X_red[2, mel_columns], nrow = 171, ncol = 40),  -->
<!-- #       xlab = "Time instants", ylab = "Mel-Frequencies", -->
<!-- #       col = col_palette) -->
<!-- ``` -->

## Linear PCA of all MEL coefficients

```{r PCA, eval = FALSE}
# X_kpca_mel <- X[, 1:6840] %>%
#   scale() %>%
#   kpca(x = .,
#        kernel = "laplacedot",
#        kpar = list(sigma = 0.00001),
#        features = 100) %>%
#   pcv() %>%
#   as.data.frame()

pc <- X[, 1:6840] %>%
  prcomp(center = TRUE, scale = TRUE)

X_pca_mel <- pc$x[, 1:50] %>% as.data.frame()
  
colnames(X_pca_mel) <- paste("pc_mel", 1:ncol(X_pca_mel), sep = "")
```

Check separation of the components

```{r Separation of PCA components, eval = FALSE}
X_pca_mel %>% 
  ggplot(aes(pc_mel3, pc_mel5)) + 
  geom_point(aes(colour = tempo)) + 
  scale_colour_gradientn(colours = RColorBrewer::brewer.pal(4, "RdYlBu"))
```

## Kernel PCA of all dominant frequencies and frequency related statistics

```{r KPCA, eval = FALSE}
X_kpca_freq <- X[, c(6841:7011, 7016:7032, 7034:7039)] %>%
  scale() %>%
  kpca(x = .,
       kernel = "rbfdot",
       kpar = list(sigma = 0.3),
       features = 20) %>%
  pcv() %>%
  as.data.frame()

colnames(X_kpca_freq) <- paste("pc_freq", 1:ncol(X_kpca_freq), sep = "")
```

Check separation of the components

```{r Separation of KPCA components, eval = FALSE}
X_kpca_freq %>%
  ggplot(aes(pc_freq1, pc_freq2)) +
  geom_point(aes(colour = tempo)) +
  scale_colour_gradientn(colours = RColorBrewer::brewer.pal(4, "RdYlBu"))
```

```{r Separation of components, eval = F}
X_kpca_freq %>% plot_ly(
  x = ~ pc_freq1,
  y = ~ pc_freq2,
  z = ~ pc_freq3,
  type = "scatter3d",
  size = 1,
  mode = "markers",
  color = tempo,
  colors = "RdYlBu"
)
```

## Group everything in final dataset

We kept everything except for the `time` columns in the original dataset
```{r Bind all data, eval = FALSE}
X_red <- cbind(X_pca_mel, X_kpca_freq, X[, "genre"])
```

# Modelling 

```{r Final dataset, eval = FALSE}
data_to_model <- tibble(X_red)
data_to_model$tempo <- tempo
```

Steps

1.  Split data in 70% Training and 30% Testing with stratified sampling

2.  Pick model

3.  Grid search to find best parameters using k-Fold Cross Validation

4.  Fit with the best parameters and compute RMSE

Training/testing

```{r Training/testing, eval = FALSE}
set.seed(123)
tr_te_split <- data_to_model %>% initial_split(prop = 0.7, strata = tempo)

training <- training(tr_te_split)
testing <- testing(tr_te_split)
```

### SVM RBF

<https://www.tidymodels.org/start/tuning/>

```{r Tuning, eval = FALSE}
# model
svm_rbf_spec <- svm_rbf(cost = tune(), rbf_sigma = tune()) %>%
  set_mode("regression") %>%
  set_engine("kernlab")

# fitting workflow
svm_rbf_wf <- workflow() %>%
  add_model(svm_rbf_spec) %>%
  add_formula(tempo ~ .)

# parallel computing
cl <- makeCluster(num_cores)
plan(cluster, workers = cl)

# construct a 5x5 grid of sensible values
# of cost and sigma to check
svm_rbf_grid <- grid_regular(cost(), rbf_sigma(), levels = 5)

# 5 folds for cross validation
folds <- vfold_cv(training, v = 5, strata = tempo)

# fit for each set of folds
# for all parameters in the grid
svm_rbf_res <- svm_rbf_wf %>%
  tune_grid(resamples = folds,
            grid = svm_rbf_grid)
```

Compare the parameters

```{r Compare tuned parameters, eval = FALSE}
svm_rbf_res %>%
  collect_metrics() %>%
  mutate(cost = factor(cost)) %>%
  ggplot(aes(rbf_sigma, mean, color = cost)) +
  geom_line(size = 1.5, alpha = 0.6) +
  geom_point(size = 2) +
  facet_wrap(~ .metric, scales = "free", nrow = 2) +
  scale_x_log10(labels = scales::label_number()) +
  scale_color_viridis_d(option = "plasma", begin = .9, end = 0)
```

Fit with the best parameters
<https://tune.tidymodels.org/reference/last_fit.html>

```{r Final fit, eval = FALSE}
best_svm <- svm_rbf_res %>% select_best("rmse")

svm_rbf_wf_final <- svm_rbf_wf %>% finalize_workflow(best_svm)

svm_rbf_fit <- svm_rbf_wf_final %>% last_fit(tr_te_split) 
stopCluster(cl)
```

Final RMSE

```{r Final RMSE, eval = FALSE}
svm_rbf_fit %>% 
  collect_metrics() %>% 
  filter(.metric == "rmse") %>%
  select(.estimate) %>%
  deframe %>%
  paste("RMSE =", .) %>%
  cat()
```

```{r Predictions, eval = FALSE}
svm_rbf_fit$.predictions
```

```{r Predictions vs tempo, eval = FALSE}
testing_rows <- svm_rbf_fit$.predictions[[1]]$.row

svm_rbf_fit$.predictions[[1]] %>%
  select(tempo, .pred, .row) %>%
  as.data.frame() %>%
  cbind(X[testing_rows, ]) %>%
  ggplot() +
    aes(tempo, .pred) +
    aes(colour = sem) +
    geom_point() + 
    geom_smooth(alpha = 0.2) +
    scale_colour_gradientn(colours = RColorBrewer::brewer.pal(4, "RdYlBu"))
```

Calculate residuals
```{r Residuals, eval = FALSE}
svm_rbf_residuals <- svm_rbf_fit$.predictions[[1]] %>%
  mutate(res = tempo - .pred) %>%
  select(res) %>%
  as.vector() %>%
  .$res
```

Check their correlation with the other variables
```{r Correlation of residuals, eval = FALSE}
cor(data_to_model[testing_rows, ], y = svm_rbf_residuals) %>% 
    tibble("corr" = as.vector(.), "feat" = rownames(.)) %>%
    filter(corr > -0.1 & corr < 0.1) %>%
    ggplot() +
      aes(x = corr, y = reorder(feat, corr)) +
      geom_col(position=position_dodge(), width = 0.8) +
      theme(axis.text=element_text(size=5))
```

Save model
<https://community.rstudio.com/t/saving-a-model-fit-with-tidymodels/114839>

```{r Save model, eval = FALSE}
svm_rbf_fit %>% 
  extract_workflow() %>% 
  readr::write_rds("svm_rbf.rds")
```

<!-- ### Random Forest -->

<!-- ```{r eval = FALSE} -->
<!-- # model -->
<!-- rf_spec <- rand_forest(mtry = tune(), trees = tune()) %>% -->
<!--   set_mode("regression") %>% -->
<!--   set_engine("ranger") -->

<!-- # fitting workflow -->
<!-- rf_wf <- workflow() %>% -->
<!--   add_model(rf_spec) %>% -->
<!--   add_formula(tempo ~ .) -->

<!-- # parallel computing -->
<!-- cl <- makeCluster(num_cores) -->
<!-- plan(cluster, workers = cl) -->

<!-- num_features <- data_to_model %>% ncol() -->

<!-- # construct a grid of values -->
<!-- # of mtry and trees to check -->
<!-- rf_grid <- expand.grid( -->
<!--           mtry =  floor(num_features * c(0.1, 0.2, 0.5, 0.99)),  -->
<!--           trees = c(200, 500, 1000, 2000) -->
<!--         ) -->

<!-- # 10 folds for cross validation -->
<!-- folds <- vfold_cv(training, v = 10, strata = tempo) -->

<!-- # fit for each set of folds -->
<!-- # for all parameters in the grid -->
<!-- rf_res <- rf_wf %>% -->
<!--   tune_grid(resamples = folds, -->
<!--             grid = rf_grid) -->
<!-- ``` -->

<!-- Compare the parameters -->

<!-- ```{r eval = FALSE} -->
<!-- rf_res %>% -->
<!--   collect_metrics() %>% -->
<!--   mutate(mtry = factor(mtry)) %>% -->
<!--   ggplot(aes(trees, mean, color = mtry)) + -->
<!--   geom_line(size = 1.5, alpha = 0.6) + -->
<!--   geom_point(size = 2) + -->
<!--   facet_wrap(~ .metric, scales = "free", nrow = 2) + -->
<!--   scale_x_log10(labels = scales::label_number()) + -->
<!--   scale_color_viridis_d(option = "plasma", begin = .9, end = 0) -->
<!-- ``` -->

<!-- Fit with the best parameters -->
<!-- <https://tune.tidymodels.org/reference/last_fit.html> -->

<!-- ```{r eval = FALSE} -->
<!-- best_rf <- rf_res %>% select_best("rmse") -->

<!-- rf_wf_final <- rf_wf %>% finalize_workflow(best_rf) -->

<!-- rf_fit <- rf_wf_final %>% last_fit(tr_te_split)  -->
<!-- stopCluster(cl) -->
<!-- ``` -->

<!-- Final RMSE -->

<!-- ```{r eval = FALSE} -->
<!-- rf_fit %>%  -->
<!--   collect_metrics() %>%  -->
<!--   filter(.metric == "rmse") %>% -->
<!--   select(.estimate) %>% -->
<!--   deframe %>% -->
<!--   paste("RMSE =", .) %>% -->
<!--   cat() -->
<!-- ``` -->
